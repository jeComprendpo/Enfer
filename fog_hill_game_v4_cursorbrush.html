<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fog Hill Village ‚Äî Version 12 (Image 1920x1080)</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root{ 
      --seal:#9c1e1e; 
      --tile-building:72px; /* taille b√¢timents */
      --tile-road:24px;     /* taille routes */
      --shadow:rgba(0,0,0,.25); 
    }
    html,body{ height:100%; margin:0; }
    body{
      font-family:"Noto Serif SC",serif;
      background:#f5f1e6;
      overflow:hidden;
      cursor: url('Image/cursor_brush_32.png') 7 7, url('Image/cursor_brush_48.png') 11 10, auto;
    }
    
    /* Styles pour les grilles */
    .grid-layer{ 
      position:absolute; 
      inset:0; 
      display:none; 
      pointer-events: none; /* Important pour ne pas bloquer les clics */
    }
    .grid-layer.show{ display:block; }
    .building-grid{ 
      background-image:linear-gradient(#00000015 1px,transparent 1px),
                       linear-gradient(90deg,#00000015 1px,transparent 1px); 
      background-size:var(--tile-building) var(--tile-building); 
    }
    .road-grid{ 
      background-image:linear-gradient(#ff000025 1px,transparent 1px),
                       linear-gradient(90deg,#ff000025 1px,transparent 1px); 
      background-size:var(--tile-road) var(--tile-road); 
    }
    
    /* Styles pour les b√¢timents */
    .building{ position:absolute; filter:drop-shadow(0 2px 4px rgba(0,0,0,.3)); transition: outline .2s; }
    .building:hover{ outline:2px solid rgba(255,0,0,0.6); }
    .building[data-type="pavillon"]{ background:url('Image/Maison.png') center/contain no-repeat }
    .building[data-type="riziere"]{ background:url('Image/Maison2.png') center/contain no-repeat }
    .building[data-type="the"]{ background:url('Image/Temple.png') center/contain no-repeat }
    .building[data-type="bambou"]{ background:url('Image/Boutique.png') center/contain no-repeat }
    .building[data-type="encens"]{ background:url('Image/forge.png') center/contain no-repeat }
    .building[data-type="autel"]{ background:url('Image/templePetit.png') center/contain no-repeat }
    
    /* Syst√®me de chemins dynamiques - fond transparent */
    .building[data-type="chemin"] {
      background: transparent;
      border: none;
      background-image: url('Image/chemin.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      transform-origin: center;
      transition: transform 0.2s ease;
    }
    
    /* Orientations des chemins selon les connexions */
    .building[data-type="chemin"][data-connections="NS"] { transform: rotate(0deg); }
    .building[data-type="chemin"][data-connections="EW"] { transform: rotate(90deg); }
    
    /* Virages - utilisation de l'image de base avec rotation */
    .building[data-type="chemin"][data-connections="NE"] { transform: rotate(0deg); }
    .building[data-type="chemin"][data-connections="SE"] { transform: rotate(90deg); }
    .building[data-type="chemin"][data-connections="SW"] { transform: rotate(180deg); }
    .building[data-type="chemin"][data-connections="NW"] { transform: rotate(270deg); }
    
    /* Intersections en T */
    .building[data-type="chemin"][data-connections="NEW"] { transform: rotate(0deg); }
    .building[data-type="chemin"][data-connections="NSE"] { transform: rotate(90deg); }
    .building[data-type="chemin"][data-connections="SEW"] { transform: rotate(180deg); }
    .building[data-type="chemin"][data-connections="NSW"] { transform: rotate(270deg); }
    
    /* Intersection compl√®te et autres cas */
    .building[data-type="chemin"][data-connections="NSEW"] { transform: rotate(0deg); }
    .building[data-type="chemin"][data-connections=""] { transform: rotate(0deg); }
    .building[data-type="chemin"][data-connections="N"] { transform: rotate(0deg); }
    .building[data-type="chemin"][data-connections="E"] { transform: rotate(90deg); }
    .building[data-type="chemin"][data-connections="S"] { transform: rotate(180deg); }
    .building[data-type="chemin"][data-connections="W"] { transform: rotate(270deg); }
    .ghost{ 
      position: absolute;
      pointer-events: none; 
      border: 2px dashed #ff0000; 
      background: rgba(255,0,0,.1); 
      opacity: .8;
      z-index: 100;
    }
    
    /* Styles pour le header */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: linear-gradient(135deg, rgba(156, 30, 30, 0.9), rgba(184, 134, 11, 0.9));
      z-index: 1000;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      backdrop-filter: blur(10px);
      border-bottom: 2px solid var(--seal);
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    
    .money-display {
      display: flex;
      align-items: center;
      background: rgba(245, 241, 230, 0.95);
      border: 2px solid #b8860b;
      border-radius: 25px;
      padding: 8px 16px;
      font-weight: 700;
      font-size: 18px;
      color: var(--seal);
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    .money-icon {
      font-size: 20px;
      margin-right: 8px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
    }
    
    .resources-display {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    
    .resource-item {
      display: flex;
      align-items: center;
      background: rgba(245, 241, 230, 0.9);
      border: 2px solid rgba(156, 30, 30, 0.6);
      border-radius: 20px;
      padding: 6px 12px;
      font-weight: 600;
      font-size: 14px;
      color: var(--seal);
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      transition: all 0.3s ease;
    }
    
    .resource-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      background: rgba(255, 255, 255, 0.95);
    }
    
    .resource-icon {
      font-size: 16px;
      margin-right: 6px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
    }
    
    .resource-value {
      font-weight: 700;
      min-width: 30px;
      text-align: right;
    }
    
    .game-wrap {
      position: fixed;
      top: 70px;
      bottom: 80px;
      left: 0;
      right: 0;
    }
    
    .world {
      position: relative;
      width: 100%;
      height: 100%;
      background: url('Image/here.png') center/cover no-repeat;
      transform-origin: 0 0;
      transition: transform 0.3s ease;
      cursor: grab;
    }
    
    .world.dragging {
      cursor: grabbing;
    }
    
    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 80px;
      background: rgba(245, 241, 230, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    
    .menu-btn {
      width: 50px;
      height: 50px;
      border: 2px solid #9c1e1e;
      background: #f5f1e6;
      border-radius: 8px;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .menu-btn:hover {
      background: #9c1e1e;
      color: white;
      transform: translateY(-2px);
    }
    
    .build-card {
      padding: 10px;
      margin: 5px;
      background: #f5f1e6;
      border: 2px solid #9c1e1e;
      border-radius: 8px;
      cursor: pointer;
      display: inline-block;
    }
    
    .build-card:hover {
      background: #9c1e1e;
      color: white;
    }
  </style>
</head>
<body>
<header class="header">
  <div class="money-display">
    <span class="money-icon">üí∞</span>
    <span class="money-value" id="moneyValue">1500</span>
    <span style="margin-left: 4px; font-size: 14px;">Èáë</span>
  </div>
  
  <div class="resources-display">
    <div class="resource-item">
      <span class="resource-icon">üåæ</span>
      <span class="resource-value" id="riceValue">45</span>
    </div>
    <div class="resource-item">
      <span class="resource-icon">üçÉ</span>
      <span class="resource-value" id="teaValue">23</span>
    </div>
    <div class="resource-item">
      <span class="resource-icon">üéã</span>
      <span class="resource-value" id="bambooValue">18</span>
    </div>
    <div class="resource-item">
      <span class="resource-icon">üïØÔ∏è</span>
      <span class="resource-value" id="incenseValue">12</span>
    </div>
    <div class="resource-item">
      <span class="resource-icon">‚õ©Ô∏è</span>
      <span class="resource-value" id="spiritualValue">7</span>
    </div>
  </div>
</header>

<main class="game-wrap">
  <section class="world" id="world">
    <div class="grid-layer building-grid" id="gridBuilding"></div>
    <div class="grid-layer road-grid" id="gridRoad"></div>
    <div class="buildings-layer" id="layer"></div>
    <div class="ghost" id="ghost" style="display:none;"></div>
  </section>
</main>

<footer class="footer">
  <div class="build-card" data-type="pavillon">üè† Maison</div>
  <div class="build-card" data-type="riziere">üåæ Rizi√®re</div>
  <div class="build-card" data-type="the">‚õ©Ô∏è Temple</div>
  <div class="build-card" data-type="bambou">üè™ Boutique</div>
  <div class="build-card" data-type="encens">‚öíÔ∏è Forge</div>
  <div class="build-card" data-type="autel">üõï Autel</div>
  <button class="menu-btn" id="pathBtn">üõ£Ô∏è</button>
  <button class="menu-btn" id="destroyBtn">üóëÔ∏è</button>
</footer>

<script>
// ===== Syst√®me de ressources =====
const resources = {
  money: 1500,
  rice: 45,
  tea: 23,
  bamboo: 18,
  incense: 12,
  spiritual: 7
};

// ===== Syst√®me de zoom et d√©placement =====
let zoomLevel = 1;
let panX = 0;
let panY = 0;
let isDragging = false;
let lastMouseX = 0;
let lastMouseY = 0;
const MIN_ZOOM = 1;
const MAX_ZOOM = 3;

// Fonction pour appliquer la transformation
function updateTransform() {
  world.style.transform = `scale(${zoomLevel}) translate(${panX}px, ${panY}px)`;
}

// Fonction pour limiter le d√©placement selon le zoom
function constrainPan() {
  const gameWrap = document.querySelector('.game-wrap');
  const maxPanX = (gameWrap.clientWidth * (zoomLevel - 1)) / (2 * zoomLevel);
  const maxPanY = (gameWrap.clientHeight * (zoomLevel - 1)) / (2 * zoomLevel);
  
  panX = Math.max(-maxPanX, Math.min(maxPanX, panX));
  panY = Math.max(-maxPanY, Math.min(maxPanY, panY));
}

// ===== Syst√®me de chemins dynamiques =====
const pathGrid = new Map(); // Stockage des chemins par position

// Fonction pour obtenir la cl√© de position
function getPositionKey(x, y) {
  return `${x},${y}`;
}

// Fonction pour v√©rifier s'il y a un chemin √† une position
function hasPathAt(x, y) {
  return pathGrid.has(getPositionKey(x, y));
}

// Fonction pour calculer les connexions d'un chemin
function calculatePathConnections(x, y) {
  const gridSize = TILE_ROAD;
  let connections = '';
  
  // V√©rifier les 4 directions : N, S, E, W
  if (hasPathAt(x, y - gridSize)) connections += 'N';
  if (hasPathAt(x, y + gridSize)) connections += 'S';  
  if (hasPathAt(x + gridSize, y)) connections += 'E';
  if (hasPathAt(x - gridSize, y)) connections += 'W';
  
  return connections;
}

// Fonction pour mettre √† jour l'apparence d'un chemin
function updatePathAppearance(pathElement, x, y) {
  const connections = calculatePathConnections(x, y);
  pathElement.setAttribute('data-connections', connections);
}

// Fonction pour mettre √† jour tous les chemins voisins
function updateNeighboringPaths(x, y) {
  const gridSize = TILE_ROAD;
  const positions = [
    [x, y - gridSize], // Nord
    [x, y + gridSize], // Sud
    [x + gridSize, y], // Est
    [x - gridSize, y]  // Ouest
  ];
  
  positions.forEach(([nx, ny]) => {
    const key = getPositionKey(nx, ny);
    if (pathGrid.has(key)) {
      const pathElement = pathGrid.get(key);
      updatePathAppearance(pathElement, nx, ny);
    }
  });
}

// Fonction pour ajouter un chemin
function addPath(x, y, pathElement) {
  const key = getPositionKey(x, y);
  pathGrid.set(key, pathElement);
  
  // Mettre √† jour ce chemin et ses voisins
  updatePathAppearance(pathElement, x, y);
  updateNeighboringPaths(x, y);
}

// Fonction pour supprimer un chemin
function removePath(x, y) {
  const key = getPositionKey(x, y);
  if (pathGrid.has(key)) {
    pathGrid.delete(key);
    updateNeighboringPaths(x, y);
  }
}

// Fonction pour mettre √† jour l'affichage des ressources
function updateResourcesDisplay() {
  document.getElementById('moneyValue').textContent = resources.money;
  document.getElementById('riceValue').textContent = resources.rice;
  document.getElementById('teaValue').textContent = resources.tea;
  document.getElementById('bambooValue').textContent = resources.bamboo;
  document.getElementById('incenseValue').textContent = resources.incense;
  document.getElementById('spiritualValue').textContent = resources.spiritual;
}

// ===== Variables de jeu =====
const TILE_BUILDING=72; 
const TILE_ROAD=24;
const world=document.getElementById('world'); 
const layer=document.getElementById('layer'); 
const ghost=document.getElementById('ghost'); 
const gridBuilding=document.getElementById('gridBuilding');
const gridRoad=document.getElementById('gridRoad');
let selectedType=null; 
let destroyMode=false;

// ===== Fonction affichage grille =====
function showGrid(type){
  // Masquer toutes les grilles
  gridBuilding.classList.remove('show');
  gridRoad.classList.remove('show');
  
  // Afficher la grille appropri√©e selon le type
  if(type==="chemin"){ 
    gridRoad.classList.add('show'); 
  }
  else if(type && type !== "destroy"){ 
    gridBuilding.classList.add('show'); 
  }
}

// ===== Placement fant√¥me avec prise en compte du zoom =====
function positionGhost(e){
  const rect=world.getBoundingClientRect();
  const x=(e.clientX-rect.left - panX) / zoomLevel;
  const y=(e.clientY-rect.top - panY) / zoomLevel;
  let gridSize=(selectedType==="chemin")?TILE_ROAD:TILE_BUILDING;
  ghost.style.left=Math.floor(x/gridSize)*gridSize+'px';
  ghost.style.top=Math.floor(y/gridSize)*gridSize+'px';
  ghost.style.width=gridSize+'px';
  ghost.style.height=gridSize+'px';
}

// Initialiser l'affichage des ressources au chargement
updateResourcesDisplay();

// ===== S√©lection des b√¢timents =====
document.querySelectorAll('.build-card').forEach(card=>{
  card.addEventListener('click',(e)=>{
    selectedType=card.dataset.type;
    destroyMode=false;
    showGrid(selectedType); // Affiche la grille appropri√©e
    // Le fant√¥me appara√Ætra quand la souris bougera dans le monde
  });
});

// ===== S√©lection du chemin =====
document.getElementById('pathBtn').addEventListener('click',e=>{
  selectedType="chemin"; 
  destroyMode=false; 
  showGrid(selectedType); // Affiche la grille des chemins
  // Le fant√¥me appara√Ætra quand la souris bougera dans le monde
});

// ===== Mode destruction =====
document.getElementById('destroyBtn').addEventListener('click',e=>{
  selectedType="destroy";
  destroyMode=true; 
  ghost.style.display="none"; 
  showGrid(null); // Masque toutes les grilles en mode destruction
});

// ===== Events du zoom (molette) =====
world.addEventListener('wheel', e => {
  e.preventDefault();
  
  const rect = world.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // Zoom vers la position de la souris
  const worldX = (mouseX - panX) / zoomLevel;
  const worldY = (mouseY - panY) / zoomLevel;
  
  const oldZoom = zoomLevel;
  
  if (e.deltaY < 0) {
    zoomLevel = Math.min(MAX_ZOOM, zoomLevel * 1.1);
  } else {
    zoomLevel = Math.max(MIN_ZOOM, zoomLevel * 0.9);
  }
  
  // Ajuster le pan pour garder la souris au m√™me endroit
  if (zoomLevel !== oldZoom) {
    panX = mouseX - worldX * zoomLevel;
    panY = mouseY - worldY * zoomLevel;
    
    constrainPan();
    updateTransform();
  }
});

// ===== Events de d√©placement (clic droit + drag) =====
world.addEventListener('mousedown', e => {
  if (e.button === 2 && zoomLevel > 1) { // Clic droit et zoom√©
    e.preventDefault();
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    world.classList.add('dragging');
  }
});

document.addEventListener('mousemove', e => {
  if (isDragging) {
    const deltaX = e.clientX - lastMouseX;
    const deltaY = e.clientY - lastMouseY;
    
    panX += deltaX / zoomLevel;
    panY += deltaY / zoomLevel;
    
    constrainPan();
    updateTransform();
    
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  }
});

document.addEventListener('mouseup', e => {
  if (e.button === 2) {
    isDragging = false;
    world.classList.remove('dragging');
  }
});

// ===== Events de la souris pour le fant√¥me =====
// ===== Events de la souris pour le fant√¥me =====
world.addEventListener('mousemove',e=>{
  if(!isDragging && selectedType && selectedType !== "destroy"){
    positionGhost(e);
  }
});

// Pour s'assurer que le fant√¥me suit bien la souris d√®s qu'on entre dans le monde
world.addEventListener('mouseenter', e=>{
  if(!isDragging && selectedType && selectedType !== "destroy"){
    ghost.style.display = 'block';
    positionGhost(e);
  }
});

// Clic droit pour annuler la s√©lection (seulement si pas en train de drag)
world.addEventListener('contextmenu',e=>{
  if (!isDragging) {
    e.preventDefault();
    selectedType=null;
    destroyMode=false;
    ghost.style.display='none';
    showGrid(null); // Masque toutes les grilles
  }
});

// Clic pour placer (avec syst√®me de chemins dynamiques)
world.addEventListener('click', e=>{
  if(!isDragging && selectedType && selectedType !== "destroy"){
    const rect=world.getBoundingClientRect();
    const x=(e.clientX-rect.left - panX) / zoomLevel;
    const y=(e.clientY-rect.top - panY) / zoomLevel;
    let gridSize=(selectedType==="chemin")?TILE_ROAD:TILE_BUILDING;
    
    const snapX = Math.floor(x/gridSize)*gridSize;
    const snapY = Math.floor(y/gridSize)*gridSize;
    
    // V√©rifier s'il y a d√©j√† quelque chose √† cette position
    const existing = Array.from(layer.children).find(building => 
      parseInt(building.style.left) === snapX && 
      parseInt(building.style.top) === snapY
    );
    
    if (!existing) {
      // Cr√©er un nouveau b√¢timent
      const building = document.createElement('div');
      building.className = 'building';
      building.dataset.type = selectedType;
      building.style.left = snapX + 'px';
      building.style.top = snapY + 'px';
      building.style.width = gridSize + 'px';
      building.style.height = gridSize + 'px';
      
      layer.appendChild(building);
      
      // Si c'est un chemin, l'ajouter au syst√®me de chemins
      if (selectedType === "chemin") {
        addPath(snapX, snapY, building);
      }
    }
  }
});

</script>
</body>
</html>